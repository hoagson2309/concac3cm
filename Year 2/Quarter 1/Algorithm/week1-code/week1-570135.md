# Week 1
# Name: SON CAO
# Student number: 570135

## Assignment 1 -  Maintain a sorted array

My code:

```cpp
#include <iostream>
#include <vector>
#include <string>
#include "utils.h"

using std::vector;
using std::string;

int binary_search(const vector<int>& arr, int value){
    int lo = 0;
    int hi = arr.size(); 
    while (lo < hi){
        int mid = lo + (hi - lo) / 2; 
        if(arr[mid] == value){
            return mid; //found
        } else if (arr[mid] < value){
            lo = mid + 1; //search in higher half
        } else {
            hi = mid; //search in lower half
        }
    }
    return lo; //insertion position
}

bool contains(const vector<int>& arr, int value){
    int pos = binary_search(arr, value); //O(log n)
    return pos < arr.size() && arr[pos] == value; //return true
}

void insert(vector<int>& arr, int value){
    int pos = binary_search(arr, value);
    if (pos < arr.size() && arr[pos] == value) return; //if contained
    arr.insert(arr.begin() + pos, value); //O(n) shift
} 

void remove(vector<int>& arr, int value){
    int pos = binary_search(arr, value);
    if(pos < arr.size() && arr[pos] == value){
        arr.erase(arr.begin() + pos); //O(n) shift
    }
}

int main() {
    // TODO: write a program that receives three arguments (through stdin):
    // a vector of integers, followed by a command ("insert", "remove" or "contains") and an integer
    // 
    // The output of the program must:
    //  if command is "insert" or "remove": the modified vector after applying the command
    //  if command is "contains": "true" (or "false") if the vector contains the element (or not)
    //
    // See the utils.h file for writing / reading vectors
    vector<int> arr;
    int value;
    string command;
    
    std::cin >> arr >> command >> value;

    if(command == "contains"){
        std::cout << (contains(arr, value) ? "true" : "false");
    } else if (command == "insert"){
        insert(arr, value);
        std::cout << arr;
    } else if (command == "remove"){
        remove(arr, value);
        std::cout << arr;
    }
    return 0;
}
```

Time complexity: this algorithm has a time complexity of O(log n) for contains, and O(n) for insert and remove. Because searching uses binary search (halving the search space each step), but inserting and removing require shifting elements in a std::vector, which takes linear time.

## Assignment 2 - First occurrence

My code:

```cpp
#include <iostream>
#include <vector>
#include "utils.h"

using std::vector;

// The program MUST use binary search to find the first occurrence of the integer
// and return its index. If the integer is not found, it should return the index
// at which the value should be inserted to maintain sorted order.
int binary_search(const vector<int>& arr, int value){
    int lo = 0;
    int hi = arr.size();

    while(lo < hi){
        int mid = lo + (hi - lo) / 2;
        if(arr[mid] < value){
            lo = mid + 1;
        } else {
            hi = mid;
        }
    }
    return lo;  //insertion position or first occurrence
}

int main() {
    // TODO: write a program that receives two arguments over stdin, separated by spaces:
    // a vector of integers, followed by an integer to search for
    //
    // The program MUST use binary search to find the first occurrence of the integer
    // and return its index. If the integer is not found, it should return the index
    // at which the value should be inserted to maintain sorted order.

    // See the utils.h file for writing / reading vectors
    vector<int> arr;
    int value;

    std::cin >> arr >> value;

    int pos = binary_search(arr, value);
    std::cout << pos;

    return 0;
}
```

Time complexity: this algorithm has a time complexity of O(log n), because each iteration of the binary search halves the search space (lo to hi).

## Assignment 3 - Partition array

My code:

```cpp
#include <iostream>
#include <vector>
#include "utils.h"
#include <string>

using std::vector;
using std::string;

void partition_array(vector<int>& arr, int value){
    int pos = 0;                       //placement pointer (where the next "kept" element should go)
    for(int i = 0; i < arr.size(); i++){  //i => scanning pointer 
        if(arr[i] != value){
            std::swap(arr[i], arr[pos]);
            pos++;
        }
    }
}

int main() {
    // TODO: write a program that receives three arguments over stdin, separated by spaces:
    // a vector of integers, followed by the word "move" and an integer
    // The program must partition the array so that all occurences of the integer
    // are placed at the end of the array.
    // Use the two-pointer technique and element swapping for this
    // See the utils.h file for writing / reading vectors
    vector<int> arr;
    int value;
    string command;

    std::cin >> arr >> command >> value;
    partition_array(arr, value);
    std::cout << arr;

    return 0;
}
```

Time complexity: this algorithm has a time complexity of O(n), because the loop scans through the array exactly once. Each element is either swapped or skipped, both of which take constant time O(1). Therefore, the total work is proportional to the number of elements n.

## Assignment 4 - Set intersection

My code:

```cpp
#include <iostream>
#include <vector>
#include "utils.h"

using std::vector;

vector<int> intersect(const vector<int>& s1, const vector<int>& s2){
    vector<int> result;
    int i = 0, j = 0;

    while(i < s1.size() && j < s2.size()){
        if(s1[i] == s2[j]){
            result.push_back(s1[i]);
            i++;
            j++;
        } else if(s1[i] < s2[j]){
            i++;
        } else {
            j++;
        }
    }
    return result;
}

int main() {
    // TODO: write a program that receives two vectors of integers as arguments over stdin
    // You may assume that the vectors are sorted in non-decreasing order, and that all
    // elements are unique.
    //
    // The program must find the intersection of the two sets and write the resulting
    // vector to stdout.
    // REQUIREMENT: the algorithm to compute the intersection must run in O(n + m) time
    //  (where n and m are the sizes of the input vectors)
    // Use the two-pointer technique to achieve this result!

    // See the utils.h file for writing / reading vectors
    vector<int> a, b;
    std::cin >> a >> b;

    vector<int> result = intersect(a, b);
    std::cout << result;
    
    return 0;
}
```

Time complexity: this algorithm has a time complexity of O(n + m), because each of the two pointers (i for s1, j for s2) only moves forward through their respective arrays. At each step, at least one pointer is incremented, so the total number of iterations is at most n + m (where n = s1.size() and m = s2.size()).


## Assignment 5 - Set subtraction

My code:

```cpp
#include <iostream>
#include <vector>
#include "utils.h"

using std::vector;

vector<int> subtract(const vector<int>& s1, const vector<int>& s2){
    vector<int> result;
    int i = 0, j = 0;

    while(i < s1.size() && j < s2.size()){
        if(s1[i] == s2[j]){
            i++;
            j++;
        } else if(s1[i] < s2[j]){  //sorted array, s1[i] < s2[i] => s1[i] cannot be appear later in s2 => s1[i] is unique to s1
            result.push_back(s1[i]);
            i++;
        } else { 
            j++; //if s1[i] > s2[j] => s2[j] can still catch up so skip it for later comparision, either '=' or '<' cases
        }
    }

    //in case s1 longer than s2 => add the remaining elements
    while (i < s1.size()){
        result.push_back(s1[i]);
        i++;
    }
    return result;
}

int main() {
    // TODO: write a program that receives two vectors of integers as arguments over stdin
    // You may assume that the vectors are sorted in non-decreasing order, and that all
    // elements are unique.
    //
    // The program must subtract the second vector from the first vector and write the resulting
    // vector to stdout.
    // REQUIREMENT: the algorithm to compute the subtraction must run in O(n + m) time
    //  (where n and m are the sizes of the input vectors)
    // Use the two-pointer technique to achieve this result!

    // See the utils.h file for writing / reading vectors
    vector<int> A, B;
    std::cin >> A >> B;

    vector<int> result = subtract(A, B);
    std::cout << result;

    return 0;
}
```

Time complexity: this algorithm has a time complexity of O(n + m), because we use two pointers (i for s1, j for s2) that only move forward through their arrays. At each step, at least one pointer is incremented, so the total number of iterations is at most n + m (where n = s1.size(), m = s2.size()).


## Assignment 6 - In-place set subtraction

My code:

```cpp
#include <iostream>
#include <vector>
#include "utils.h"

// Function prototype - you must implement this function
/// @brief Subtracts set b from set a, modifying a in place.
/// @param a First set (will be modified to contain the result)
/// @param b Second set (will not be modified)
void subtract_sets_inplace(std::vector<int>& a, const std::vector<int>& b);

void subtract_sets_inplace(std::vector<int>& a, const std::vector<int>& b){
    int i = 0;
    int j = 0;
    int k = 0;

    while(i < a.size() && j < b.size()){
        if(a[i] == b[j]){ //skip
            i++;
            j++;
        } else if (a[i] < b[j]){  //element is unique to a => keep
            a[k] = a[i];
            i++;
            k++;
        } else {
            j++;
        }
    }
    while (i < a.size()){
        a[k++] = a[i++];
    }
    a.resize(k); //cut off the garbage at the back.
}

int main() {
    // TODO: write a program that receives two vectors of integers as arguments over stdin
    // You may assume that the vectors are sorted in non-decreasing order, and that all
    // elements are unique.
    //
    // The program must subtract the second vector from the first vector and write the resulting
    // vector to stdout.
    // REQUIREMENT (1): the algorithm to compute the subtraction must run in O(n + m) time
    //  (where n and m are the sizes of the input vectors)
    // REQUIREMENT (2): the algorithm must modify the first vector in place
    //  Use the provided function prototype for this
    // Use the two-pointer technique to achieve this result!

    // See the utils.h file for writing / reading vectors
    std::vector<int> a, b;
    std::cin >> a >> b;

    subtract_sets_inplace(a, b);

    std::cout << a;
    return 0;
}
```

Time complexity: this algorithm has a time complexity of O(n + m), because it uses three pointers: i scans through vector a, j scans through vector b, and k marks the position to overwrite in a. At every step, at least one of i or j is incremented, so the total number of iterations is at most n + m (where n = a.size(), m = b.size()).
